use std::str::FromStr;

use crate::ast::{Expression, OpCode, UnCode, ExpressionTransform};

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `# comments`
    _
}

pub Expression: Box<Expression> = Expr00;

Expr00: Box<Expression> = {
    <left: Expression> <operation: Op10> <right: Expr10> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr10,
};

Expr10: Box<Expression> = {
    <left: Expr10> <operation: Op20> <right: Expr20> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr20,
};

Expr20: Box<Expression> = {
    <left: Expr20> <operation: Op30> <right: Expr30> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr30,
};

Expr30: Box<Expression> = {
    <left: Expr30> <operation: Op40> <right: Expr40> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr40,
};

Expr40: Box<Expression> = {
    <left: Expr40> <operation: Op50> <right: Expr50> => Box::new(Expression::BinaryOperation { left, right, operation }),
    Expr41,
};

Expr41: Box<Expression> = {
    <operation: Un10> <right: Expr50> => Box::new(Expression::UnaryOperation { right, operation }),
    Expr50,
};

Expr50: Box<Expression> = {
    <left: Expr50> "?" <truthy: Expr60> ":" <falsy: Expr60> => Box::new(Expression::Conditional {left, truthy, falsy}),
    Expr51,
};

Expr51: Box<Expression> = {
    "if" <left: Expr51> "{" <truthy: Expr60> "}" "else" "{" <falsy: Expr60> "}" => Box::new(Expression::Conditional {left, truthy, falsy}),
    Expr60,
};

Expr60: Box<Expression> = {
    <subject: Expr60> "|" <name: Identifier> <args: Args?> => Box::new(Expression::Transform{name, subject, args}),
    Expr70
};

Expr70: Box<Expression> = {
    <subject: Expr60>  "|" "mapTransform(" <name: Identifier> <args: Args?> ")" => Box::new(Expression::MapTransform {name, subject, args }),
    Expr80
}

Expr80: Box<Expression> = {
    <subject: Expr60> "|" "filterTransform(" <name: Identifier> <args: Args?> ")" => Box::new(Expression::FilterTransform {name, subject, args }),
    Expr81
}

Expr81: Box<Expression> = {
    <subject: Expr60>  "|" <name: ET> "(" <expression: Expression> ","? <args: Number?> ")" => Box::new(Expression::ExpressionTransform {name, subject, expression, args }),
    Expr82
}

Expr82: Box<Expression> = {
    <subject: Expr60> "|" "reduce(" <init: Expression> "," <expression: Expression> ")" => Box::new(Expression::ReduceExpression { subject, init, expression }),
    Expr85
}

Expr85: Box<Expression> = {
    "date(" <date: Expr85> "," <format: Expression> ")" => Box::new(Expression::Date { date, format }),
    Expr86
}

Expr86: Box<Expression> = {
    "datetime(" <datetime: Expr80> "," <format: Expression> ")" => Box::new(Expression::DateTime { datetime, format }),
    Expr87
}

Expr87: Box<Expression> = {
    "duration(" <duration: Expr80> "," <duration_type: Expression> ")" => Box::new(Expression::Duration { duration, duration_type }),
    Expr88
}

Expr88: Box<Expression> = {
   "$now" => Box::new(Expression::Now),
    Expr90
}

Expr90: Box<Expression> = {
    <subject: Expr70> <index: Index> => Box::new(Expression::IndexOperation{subject, index}),
    <subject: Expr70> "." <ident: Identifier>  => Box::new(Expression::DotOperation{subject, ident}),
    Expr100
};

Expr100: Box<Expression> = {
    Number => Box::new(Expression::Number(<>)),
    Boolean => Box::new(Expression::Boolean(<>)),
    String => Box::new(Expression::String(<>)),
    Array => Box::new(Expression::Array(<>)),
    Object => Box::new(Expression::Object(<>)),
    Identifier => Box::new(Expression::Identifier(<>)),
    Regex => Box::new(Expression::Regex(<>)),
    "(" <Expression> ")",
};

Args: Vec<Box<Expression>> = {
    "(" <Comma<Expression>> ")"
};

Un10: UnCode = {
    "!" => UnCode::Not,
    "-" => UnCode::Minus,
    "+" => UnCode::Plus,
}

Op10: OpCode = {
    "&&" => OpCode::And,
    "||" => OpCode::Or,
};

Op20: OpCode = {
    "==" => OpCode::Equal,
    "!=" => OpCode::NotEqual,
    ">=" => OpCode::GreaterEqual,
    "<=" => OpCode::LessEqual,
    ">" => OpCode::Greater,
    "<" => OpCode::Less,
    "in" => OpCode::In,
    "~" => OpCode::Matches,
    "@" => OpCode::Capture,
    "@+" => OpCode::CaptureMultiple,
};

Op30: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Subtract,
};

Op40: OpCode = {
    "*" => OpCode::Multiply,
    "//" => OpCode::FloorDivide,
    "/" => OpCode::Divide,
};

Op50: OpCode = {
    "%" => OpCode::Modulus,
    "^" => OpCode::Exponent,
};

ET: ExpressionTransform = {
    "map" => ExpressionTransform::Map,
    "filter" => ExpressionTransform::Filter,
    "sortBy" => ExpressionTransform::SortBy,
    "any" => ExpressionTransform::Any,
    "all" => ExpressionTransform::All,
    "find" => ExpressionTransform::Find,
    "findIndex" => ExpressionTransform::FindIndex,
    "apply" => ExpressionTransform::Apply,
};

Number: f64 = {
    r"-?[0-9]+" => f64::from_str(<>).unwrap(),
    r"-?[0-9]+\.[0-9]*" => f64::from_str(<>).unwrap(),
    r"-?\.[0-9]+" => f64::from_str(<>).unwrap(),
};

String: String = {
    <s: r#""([^"\\]*(\\")?)*""#> => s[1..s.len() - 1].to_string().replace("\\\"", "\""),
    <s: r#"'([^'\\]*(\\')?)*'"#> => s[1..s.len() - 1].to_string().replace("\\'", "'"),
};

Regex: String = {
    <s: r#"/([^']*(\\')?)*/"#> => s[1..s.len() - 1].to_string(),
}

Identifier: String = {
    r#"[a-zA-Z_][a-zA-Z0-9_]*"# => <>.to_string()
}

Index: Box<Expression> = {
    "[" "." <ident: Identifier> <op: Op20> <right: Expr80> "]" => Box::new(Expression::Filter {ident, op, right}),
    "[" <Expression> "]",
}

Boolean: bool = {
    "true" => true,
    "false" => false,
}

Comma<T>: Vec<T> = {
    <v: (<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Array: Vec<Box<Expression>> = {
    "[" <Comma<Expression>> "]"
}

Object: Vec<(String, Box<Expression>)> = {
    "{" <Comma<(<ObjectIdentifier> ":" <Expression>)>> "}",
    "{}" => vec![],
}

ObjectIdentifier: String = {
    String, 
    Identifier
}
